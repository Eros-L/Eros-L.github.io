---
title: 算法分析课程博客分享1
date: 2018-09-04 20:26:00
description: 665. 非递减数列
categories:
 - share
tags: 
- leetcode
---

## 算法分析课程博客分享&nbsp;1

----------

### 665. [非递减数列(Non-decreasing Array)](https://leetcode-cn.com/problems/non-decreasing-array/description/)

给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。 <br />
我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 <= i < n)，满足 array[i] <= array[i + 1]。 <br />
> 示例 1: <br />
> 输入: [4,2,3] <br />
> 输出: True <br />
> 解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。 <br />

> 示例 2: <br />
> 输入: [4,2,1] <br />
> 输出: False <br />
> 解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 <br />

<br />
解题思路:
本题所传入的参数是一个一维数组，为了更好地看清问题的本质，我们先将题目假设为不能改变任何元素的情况下，该数组是否为非递减数列。此时，我们仅需严格按照非递减数列的定义对数组进行一次扫描即可，具体代码如下。 <br />
```
bool checkPossibility(vector<int>& nums) {
    int size = nums.size();
    for (int i = 1; i < size; ++i) {
        if (nums[i-1] > nums[i])
            return false;
    }
    return true;
}
```
<br />
而当问题变为最多允许改变一个元素，当我们检测到一组不满足非递减数列的值并对其进行修改后，我们可以获得两种结果，第一种是修改后的数据对剩余数据非递减性不产生影响，第二种则是修改后的数据对剩余数据非递减性产生了影响。接下来，我们将分情况去讨论这个问题。 <br />
我们可以以输入 [4,2,3] 为例，其中不符合定义的数据为 [4,2]。此时，我们的修改方案可以是将 4 改成 2 或者是将 2 改成 4。若我们执行第一种修改，由于 4 的前面没有其他的数据，将 4 缩小成 2 不会导致前面存在比 2 大的数据。若我们执行第二种修改，将 2 放大成 4 后，其后的 3 便会变得比 4 要小，因此，这种修改是不满足题目要求的。 <br />
在理解清楚题目要求后，我们以输入 [3,4,2,3] 为例来推出题目的解法。当我们对数组进行扫描时，第一组不符合定义的数据为 [4,2]，此时我们存在两种修改方案，显然执行缩小修改会使得新数组中的数据 [3,2] 不符合定义，因此，我们必须执行放大修改。要注意的是，在数据 [4,2] 前的所以数据都是符合非递减定义的，所以，数据 4 的上一个数必然是 4 前面所有数据的最大值，故我们只需检测 4 的上一个数是否比 2 大 即可判断能否执行缩小修改。执行放大修改后，我们得到的新数组是 [3,4,4,3]，显然，数据 [4,3] 是不符合定义的，因此我们无法仅修改一个数就让输入变成非递减数列。在数次优化效率后，AC代码如下。 <br />
```
bool checkPossibility(vector<int>& nums) {
    int size = nums.size();
    bool flag = false;
    for (int i = 1; i < size; ++i) {
        if (nums[i-1] > nums[i]) {
            if (flag)
                return false;
            if (i > 1 && nums[i-2] > nums[i]) {
                nums[i] = nums[i-1];
            }
            flag = true;
        }
    }
    return true;
}
```
<br />
其中，变量 flag 用于标记此前是否已经修改过数组中的元素，判断条件 (i > 1 && nums[i-2] > nums[i]) 用于判断是否执行放大操作。实际上，由于扫描的下标是由 1 开始的，判断执行缩小操作的条件为 (i == 1 || nums[i-2] <= nums[i])，但是执行缩小操作并不需要改变原数组的数据也能得到正确的结果，因此，我们只需要在执行放大操作时放大 nums[i] 即可，这样可以减少 IO 的次数。最后，此段代码的时间复杂度为 O(n)。 <br />

----------

### xxx.