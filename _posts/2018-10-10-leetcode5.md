---
title: 算法分析课程博客分享&nbsp;5
date: 2018-10-10 23:57:00
description: 542. 01 矩阵、200. 岛屿的个数、773. 滑动谜题
categories:
 - share
tags: 
- leetcode
---

## 算法分析课程博客分享&nbsp;5

----------

### 542. [01 矩阵(01 Matrix)](https://leetcode-cn.com/problems/01-matrix/description/)

给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。 <br />

两个相邻元素间的距离为 1 。 <br />

> 示例 1: <br />
> 输入: <br />
> 0 0 0 <br />
> 0 1 0 <br />
> 0 0 0 <br />
> 输出: <br />
> 0 0 0 <br />
> 0 1 0 <br />
> 0 0 0 <br />

> 示例 2: <br />
> 输入: <br />
> 0 0 0 <br />
> 0 1 0 <br />
> 1 1 1 <br />
> 输出: <br />
> 0 0 0 <br />
> 0 1 0 <br />
> 1 2 1 <br />

**注意:** <br />
- 给定矩阵的元素个数不超过 10000。
- 给定矩阵中至少有一个元素是 0。
- 矩阵中的元素只在四个方向上相邻: 上、下、左、右。


解题思路: <br />
刚开始的时候，我考虑过能否使用 O(V) 的复杂度来解决问题，但实际上，我们必须考虑所有的路径才可以得出结果。首先，我们对矩阵进行一次扫描，获得所有的 0 的位置，并将这些位置的距离值设为 0，其余位置的距离值设为 INT_MAX，然后从 0 开始进行广搜。对于一个 0 点，我们将其周围的四个点的距离值设为 1，然后将这四个点放入队列中；对于一个 1 点，若周围的一个点的距离值大于当前点距离值加一，我们就更新这个周围点的距离值，并将更新过的点放入队列中，否则不进行操作。具体代码如下: <br />

```
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) {
        if (matrix.empty() || matrix[0].empty())
            return vector<vector<int>>();
        
        vector<vector<int>> dis(matrix.size(), vector<int>(matrix[0].size(), INT_MAX));
        queue<pair<int, int>> q;
        for (int i = 0; i < matrix.size(); ++i) {
            for (int j = 0; j < matrix[i].size(); ++j) {
                if (matrix[i][j] == 0) {
                    q.push(make_pair(i, j));
                    dis[i][j] = 0;
                }
            }
        }
        while (!q.empty()) {
            pair<int, int> cur = q.front();
            q.pop();
            for (int i = 0; i < 4; ++i) {
                int x = cur.first + dir[i][0], y = cur.second + dir[i][1];
                if (x >= 0 && x < matrix.size() && y >= 0 && y < matrix[0].size()) {
                    if (dis[x][y] > dis[cur.first][cur.second] + 1) {
                        dis[x][y] = dis[cur.first][cur.second] + 1;
                        q.push(make_pair(x, y));
                    }
                }
            }
        }
        return dis;
    }
    
private:
    int dir[4][2] = { {-1, 0}, {0, 1}, {1, 0}, {0, -1} };
```
<br />


----------

### 200. [岛屿的个数(Number of Islands)](https://leetcode-cn.com/problems/number-of-islands/description/)

给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 <br />

> 示例 1: <br />
> 输入: <br />
> 11110 <br />
> 11010 <br />
> 11000 <br />
> 00000 <br />
> 输出: 1 <br />

> 示例 2: <br />
> 输入: <br />
> 11000 <br />
> 11000 <br />
> 00100 <br />
> 00011 <br />
> 输出: 3 <br />


解题思路: <br />
这道题和上一题的思路类似，但是，因为这道题与广搜的路径无关，所以我们可以使用 O(V) 复杂度解决这个问题。我们首先对矩阵进行扫描，当检测到值为 1 的点的时候，代表我们发现了一个岛，这时候我们要令 count 的值加一。然后，我们从当前检测到的点开始进行广搜，把与其属于同一个岛的点全部设为 0，以确保我们在扫描矩阵时不会扫描到属于同一个岛的多个值为 1 的点。最后，count 的值就是岛屿的个数，具体代码如下: <br />

```
public:
    int numIslands(vector<vector<char>>& grid) {
        int count = 0;
        for (int i = 0; i < grid.size(); ++i) {
            for (int j = 0; j < grid[0].size(); ++j) {
                if (grid[i][j] == '1') {
                    ++count;
                    bfs(grid, i, j);
                }
            }
        }
        return count;
    }
    
private:
    int dir[4][2] = { {-1, 0}, {0, 1}, {1, 0}, {0, -1} };
    
    void bfs(vector<vector<char>>& grid, int x, int y) {
        if (grid[x][y] == '0')
            return;
        grid[x][y] = '0';
        for (int i = 0; i < 4; ++i) {
            int nextX = x + dir[i][0], nextY = y + dir[i][1];
            if (nextX >= 0 && nextX < grid.size() && nextY >= 0 && nextY < grid[0].size()) {
                bfs(grid, nextX, nextY);
            }
        }
    }
```
<br />


----------