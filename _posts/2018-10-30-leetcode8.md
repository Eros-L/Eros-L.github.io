---
title: 算法分析课程博客分享&nbsp;8
date: 2018-10-23 16:43:00
description: 322. 零钱兑换
categories:
 - share
tags: 
- leetcode
---

## 算法分析课程博客分享&nbsp;8

----------

### 322. [零钱兑换(Coin Change)](https://leetcode-cn.com/problems/coin-change/)

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 <br />

> 示例 1: <br />
> 输入: coins = [1, 2, 5], amount = 11 <br />
> 输出: 3 <br />
> 解释: 11 = 5 + 5 + 1 <br />

> 示例 2: <br />
> 输入: coins = [2], amount = 3 <br />
> 输出: -1 <br />

**说明:** <br />
- 你可以认为每种硬币的数量是无限的。


解题思路: <br />
这是一道完全背包问题的推广题，观察题目，我们可以将总金额 *amount* 视为背包的容量，*coins* 视为不同的物品，而每件物品的价值皆为 1。在这个视角下，我们将问题转换为求往容量为 *c* 的背包中放满物品时，背包的最小价值。因此，动态规划的转换函数为： <br />
- c < coins[n]: dp&91;n&93;&91;c&93; = dp&91;n-1&93;&91;c&93;
- c >= coins[n]: dp&91;n&93;&91;c&93; = min(dp&91;n-1&93;&91;c&93;, dp&91;n&93;&91;c-coins&91;n&93;+1)
首先，我们对 dp 矩阵进行初始化，我们将矩阵的所有位置都初始化为 *amount*+1，表示无法将背包放满。注意，因为硬币的体积至少为 1，所以放满一个容量为 *amount* 的背包至多需要 *amount*+1 个硬币。接下来，我们需要对 coins[0] 进行特殊处理，显然，只使用 coins[0] 来填充背包的话，当且仅当 c % coins[0] == 0 时能放满的，而此时放满所需的硬币数目为 c / coins[0]。当然，我们也可以用状态转移方程来对 coins[0] 进行处理，此时替换的代码如下： <br />

```
dp[0][0] = 0;
for (int c = 0; c <= amount; ++c) {
    if (c >= coins[0]) {
        dp[0][c] = min(dp[0][c], dp[0][c-coins[0]]+1);
    }
}
```
<br />
之后，我们就只需解决一个经典的完全背包问题，具体代码如下： <br />

```
int coinChange(vector<int>& coins, int amount) {
    vector<vector<int>> dp(coins.size(), vector<int>(amount+1, amount+1));
    for (int c = 0; c <= amount; ++c) {
        if (c % coins[0] == 0) {
            dp[0][c] = c / coins[0];
        }
    }
    for (int n = 1; n < coins.size(); ++n) {
        for (int c = 0; c <= amount; ++c) {
            if (c < coins[n]) {
                dp[n][c] = dp[n-1][c];
            } else {
                dp[n][c] = min(dp[n-1][c], dp[n][c-coins[n]]+1);
            }
        }
    }

    int count = dp[coins.size()-1][amount];
    return (count == amount+1) ? (-1) : (count);
}
```
<br />
其实，我们也可以发现，题目并不要求我们保留硬币的选取方案，故我们可以改用一个一维数组来进行动态规划，从而优化程序的复杂度。具体代码如下： <br />

```
int coinChange(vector<int>& coins, int amount) {
    vector<int> dp(amount+1, amount+1);
    dp[0] = 0;
    for (int n = 0; n < coins.size(); ++n) {
        for (int c = 1; c <= amount; ++c) {
            if (c >= coins[n]) {
                dp[c] = min(dp[c], dp[c-coins[n]]+1);
            }
        }
    }

    return (dp[amount] == amount+1) ? (-1) : (dp[amount]);
}
```
<br />


----------

### 787. [K 站中转内最便宜的航班(Cheapest Flights Within K Stops)](https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/)

有 n 个城市通过 m 个航班连接。每个航班都从城市 u 开始，以价格 w 抵达 v。 <br />

现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到从 src 到 dst 最多经过 k 站中转的最便宜的价格。 如果没有这样的路线，则输出 -1。  <br />

> 示例 1: <br />
> 输入: <br />
> n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] <br />
> src = 0, dst = 2, k = 1 <br />
> 输出: 200 <br />
> 解释: <br />
> 城市航班图如下 <br />
> ![](https://raw.githubusercontent.com/Eros-L/Eros-L.github.io/master/_posts/leetcode/787.png)
> 从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。 <br />

> 示例 2: <br />
> 输入: <br />
> n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] <br />
> src = 0, dst = 2, k = 0 <br />
> 输出: 500 <br />
> 解释: <br />
> 城市航班图如下 <br />
> ![](https://raw.githubusercontent.com/Eros-L/Eros-L.github.io/master/_posts/leetcode/787.png)
> 从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。 <br />

**提示：** <br />
- n 范围是 [1, 100]，城市标签从 0 到 n - 1.
- 航班数量范围是 [0, n * (n - 1) / 2].
- 每个航班的格式 (src, dst, price).
- 每个航班的价格范围是 [1, 10000].
- k 范围是 [0, n - 1].
- 航班没有重复，且不存在环路


解题思路: <br />
这道题目虽然是求加权图的最短路径，但是题目限制了可以经过的节点的数目，因此，直接套用 Dijkstra 等算法貌似不太可行。考虑到这一点，我们可以遍历所有节点数小于等于 K 的路径，然后求出最短的加权路径。题目给出的 flights 数组是若干乱序的加权边，故应用 DFS 或 BFS 前，我们需要先做一个预处理，将 flights 数组转换为一个邻接列表。接下来，我们使用队列进行广搜，我们将节点储存为 (index, cost) 的形式，同时，我们用一个整型变量 cost 来记录最便宜的路线。我们分层来进行遍历，对于每一层的节点，我们检测与它们相连的节点，若当前节点与 dst 相连，我们将更新 cost 的值，否则，我们将总价格小于 cost 的线路放进队列中。注意，如果我们往队列中放入新节点时，不筛选掉价格大于等于 cost 的线路，我们的内存将超过限制，具体代码如下： <br />

```
int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {
    vector<vector<pair<int, int>>> edges(n, vector<pair<int, int>>());
    for (vector<int> e : flights) {
        edges[e[0]].push_back(make_pair(e[1], e[2]));
    }

    queue<pair<int, int>> q{ {make_pair(src, 0)} };        
    int cost = INT_MAX;
    for (int i = 0; !q.empty() && i <= K; ++i) {
        int size = q.size();
        for (int j = 0; j < size; ++j) {
            pair<int, int> u = q.front();
            q.pop();
            for (pair<int, int> e : edges[u.first]) {
                if (e.first == dst) {
                    cost = min(cost, u.second+e.second);
                } else if (cost > u.second+e.second) {
                    q.push(make_pair(e.first, u.second+e.second));
                }
            }
        }
    }

    return (cost == INT_MAX) ? -1 : cost;
}
```
<br />
虽然上述的算法效率已经不错，但在查阅资料后，我发现了一种更巧妙的基于 Bellman Ford 的解法。其中，我们用 1e9 来表示距离为无穷，不使用 INT_MAX 是为了防止进行加法后超出数据类型的范围。由于每次循环都要遍历所有的边，这个算法会比上述的要稍慢，具体代码如下： <br />

```
int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {
    vector<int> dist(n, 1e9);
    dist[src] = 0;
    for (int i = 0; i <= K; ++i) {
        vector<int> tmp = dist;
        for (vector<int> f : flights) {
            tmp[f[1]] = min(tmp[f[1]], dist[f[0]]+f[2]);
        }
        dist = tmp;
    }

    return (dist[dst] >= 1e9) ? -1 : dist[dst];
}
```
<br />


----------

### 815. [公交路线(Bus Routes)](https://leetcode-cn.com/problems/bus-routes/)

我们有一系列公交路线。每一条路线 routes[i] 上都有一辆公交车在上面循环行驶。例如，有一条路线 routes[0] = [1, 5, 7]，表示第一辆 (下标为0) 公交车会一直按照 1->5->7->1->5->7->1->... 的车站路线行驶。 <br />

假设我们从 S 车站开始（初始时不在公交车上），要去往 T 站。 期间仅可乘坐公交车，求出最少乘坐的公交车数量。返回 -1 表示不可能到达终点车站。 <br />s

> 示例: <br />
> 输入: <br />
> routes = [[1, 2, 7], [3, 6, 7]] <br />
> S = 1 <br />
> T = 6 <br />
> 输出: 2 <br />
> 解释: <br />
> 最优策略是先乘坐第一辆公交车到达车站 7, 然后换乘第二辆公交车到车站 6。 <br />

**说明:** <br />
- 1 <= routes.length <= 500.
- 1 <= routes[i].length <= 500.
- 0 <= routes[i][j] < 10 ^ 6.


解题思路: <br />
本想着用 Dijkstra 或 Bellman Ford 算法来求解，但仔细思考过后，发现这道题的本质是一个无权图，因此仅需用广搜即可求解。题目的难点在于给出的 routes 的存储格式并不是我们所熟悉的邻接列表之类的，而是每一辆公交的线路，故我们需要先对 routes 进行预处理。最简单的思路是计算一个 src 到 dst 的邻接列表，其中，每条路径的长度皆为 1。但是，在这道题中，bus stop 的数目最多为 1e6 个，计算上述的邻接列表会导致在部分复杂的用例中超出内存限制，所以我们只能生成一个 src 与 bus 的邻接列表，代表经过某个车站的所有公交车。接下来，我们只需要简单地套用分层的广搜算法即可获得最短路径。然而，考虑到邻接列表的储存格式，我们需要在遍历 routes[bus] 才可以获得从 src 搭乘 bus 能到达的所有车站。这种操作显然会导致超时或超出内存限制，因此，我们需要记录下去过的车站与搭乘过的公交车，以确保我们不会重复访问去过的车站或搭乘过的公交车。这里，为了节省空间的使用，我使用了一个比较 tricky 的办法，当遍历完一条公交线路时，我们将把这条线路删除以避免重复访问，当遍历完一个车站时，我们将把这个车站删除以避免重复访问。当然，这个操作也可以通过一个 visited 数组来替代，只是会造成多一点的内存开销。具体代码如下： <br />

```
int numBusesToDestination(vector<vector<int>>& routes, int S, int T) {
    if (S == T)
        return 0;

    unordered_map<int, unordered_set<int>> path;
    for (int i = 0; i < routes.size(); ++i) {
        for (int src : routes[i]) {
            path[src].insert(i);
        }
    }

    queue<int> q{ {S} };
    int dist = 1;
    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; ++i) {
            int src = q.front();
            q.pop();
            for (int bus : path[src]) {
                for (int dst : routes[bus]) {
                    if (dst == T)
                        return dist;
                    q.push(dst);
                }
                routes[bus].clear();
            }
            path[src].clear();
        }
        ++dist;
    }

    return -1;
}
```
<br />

